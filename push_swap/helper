
12 20 10 26 17 13 14 2 6 16 15 0 5 19 4 21 25 8 11 27 29 24 9 3 18 22 1 28 23 7


"args":["12 20 10 26 17 13 14 2 6 16 15 0 5 19 4 21 25 8 11 27 29 24 9 3 18 22 1 28 23 7"],

below i have two functions. In the push_prep funciton. I use the copy = copy_node() funciton so that I can copy the node of hold. Hold is a single
node inside of the doubly linked list **a. when I use copy, it seems to make **a reference an invalid address. Can you see why this would be? I
am happy to hand in a double pointer to copy node if that will resolve the issue. 

int	push_prep(t_node **a, t_node **b, t_node *hold, int chunk)
{
	int		rb;
	int		rrb;
	int		size;
	t_node	*copy;

	copy = copy_node(hold);
	size = ft_lstlast(*a)->pos + 1;
	rb = pb_rot_push(copy, b, chunk);
	rrb = pb_rev_push(copy, b, chunk);
	if (hold->pos < size / 2)
		push_prep_rr(a, b, hold, rb);
	else if (hold->pos > size / 2)
		push_prep_rrr(a, b, hold, rrb);
	ft_lstclear(&copy);

}

t_node	*copy_node(t_node *node)
{
	t_node	*copy;

	if (!node)
	return (NULL);
	ft_lstadd_front(&copy, ft_lstnew(node->num, node->pos,
		node->stack[0]));
	if (!copy)
	return (NULL);
	copy->prev = NULL;
	copy->next = NULL;
	return (copy);
}
